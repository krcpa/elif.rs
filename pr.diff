diff --git a/Cargo.lock b/Cargo.lock
index 83ca3f6..8e25f9a 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -1614,6 +1614,7 @@ name = "elif-http-derive"
 version = "0.1.0"
 dependencies = [
  "async-trait",
+ "elif-http 0.8.0",
  "proc-macro2",
  "quote",
  "syn 2.0.106",
diff --git a/crates/elif-http-derive/Cargo.toml b/crates/elif-http-derive/Cargo.toml
index 94adcdc..bb6e172 100644
--- a/crates/elif-http-derive/Cargo.toml
+++ b/crates/elif-http-derive/Cargo.toml
@@ -20,4 +20,5 @@ syn = { version = "2.0", features = ["full", "extra-traits"] }
 async-trait = "0.1"
 
 [dev-dependencies]
-trybuild = "1.0"
\ No newline at end of file
+trybuild = "1.0"
+elif-http = { path = "../elif-http" }
\ No newline at end of file
diff --git a/crates/elif-http-derive/src/controller.rs b/crates/elif-http-derive/src/controller.rs
index 169031b..b6609aa 100644
--- a/crates/elif-http-derive/src/controller.rs
+++ b/crates/elif-http-derive/src/controller.rs
@@ -6,7 +6,10 @@ use proc_macro::TokenStream;
 use quote::quote;
 use syn::{parse_macro_input, ItemStruct, ItemImpl, ImplItem, LitStr};
 
-use crate::utils::{extract_http_method_info, extract_middleware_from_attrs};
+use crate::utils::{
+    extract_http_method_info, extract_middleware_from_attrs, 
+    extract_path_parameters, extract_param_types_from_attrs
+};
 
 /// Controller macro for defining controller base path and metadata
 /// 
@@ -80,13 +83,36 @@ pub fn controller_impl(args: TokenStream, input: TokenStream) -> TokenStream {
                     let middleware = extract_middleware_from_attrs(&method.attrs);
                     let middleware_vec = quote! { vec![#(#middleware.to_string()),*] };
                     
+                    // Extract path parameters from the route path
+                    let path_params = extract_path_parameters(&path);
+                    
+                    // Extract parameter type specifications from #[param] attributes
+                    let param_types = extract_param_types_from_attrs(&method.attrs);
+                    
+                    // Build parameter metadata with proper types
+                    let mut param_tokens = Vec::new();
+                    for param_name in &path_params {
+                        // Get the type from #[param] attributes, default to String
+                        let param_type = param_types.get(param_name).cloned().unwrap_or_else(|| "String".to_string());
+                        let param_type_enum = match param_type.as_str() {
+                            "String" => quote! { ParamType::String },
+                            "Integer" => quote! { ParamType::Integer },
+                            "Uuid" => quote! { ParamType::Uuid },
+                            _ => quote! { ParamType::String }, // Default fallback
+                        };
+                        
+                        param_tokens.push(quote! {
+                            RouteParam::new(#param_name, #param_type_enum)
+                        });
+                    }
+                    
                     routes.push(quote! {
                         ControllerRoute {
                             method: HttpMethod::#http_method_variant,
                             path: #path.to_string(),
                             handler_name: #handler_name.to_string(),
                             middleware: #middleware_vec,
-                            params: vec![], // TODO: Extract params in future phases
+                            params: vec![#(#param_tokens),*],
                         }
                     });
                     
diff --git a/crates/elif-http-derive/src/utils.rs b/crates/elif-http-derive/src/utils.rs
index 33f1a09..678e7bb 100644
--- a/crates/elif-http-derive/src/utils.rs
+++ b/crates/elif-http-derive/src/utils.rs
@@ -2,6 +2,7 @@
 
 use syn::{Attribute, Meta, Signature, FnArg, Pat, PatIdent};
 use quote::quote;
+use std::collections::HashMap;
 
 /// Extract HTTP method and path from method attributes
 pub fn extract_http_method_info(attrs: &[Attribute]) -> Option<(proc_macro2::Ident, String)> {
@@ -219,4 +220,82 @@ pub fn extract_middleware_from_attrs(attrs: &[Attribute]) -> Vec<String> {
     }
     
     middleware
+}
+
+/// Convert param type from derive crate to routing crate format
+pub fn convert_param_type_to_routing(param_type: &str) -> String {
+    match param_type {
+        "string" => "String".to_string(),
+        "int" => "Integer".to_string(),  
+        "uint" => "Integer".to_string(),
+        "uuid" => "Uuid".to_string(),
+        "float" => "String".to_string(), // Float not in routing::ParamType yet
+        "bool" => "String".to_string(),  // Bool not in routing::ParamType yet
+        _ => "String".to_string(), // Default fallback
+    }
+}
+
+/// Extract parameter type specifications from method attributes
+/// Returns a map of parameter name -> parameter type
+pub fn extract_param_types_from_attrs(attrs: &[Attribute]) -> HashMap<String, String> {
+    let mut param_types = HashMap::new();
+    
+    for attr in attrs {
+        if attr.path().is_ident("param") {
+            if let Meta::List(meta_list) = &attr.meta {
+                // Parse parameter specifications from the attribute tokens
+                let tokens = &meta_list.tokens;
+                
+                // Try to parse multiple comma-separated param specs: id: int, name: string
+                if let Ok(parsed_specs) = parse_param_specs(tokens.clone()) {
+                    for (name, type_str) in parsed_specs {
+                        let routing_type = convert_param_type_to_routing(&type_str);
+                        param_types.insert(name, routing_type);
+                    }
+                }
+            }
+        }
+    }
+    
+    param_types
+}
+
+/// Parse parameter specifications from token stream
+/// Expected format: "id: int, name: string" or just "id: int"
+fn parse_param_specs(tokens: proc_macro2::TokenStream) -> Result<Vec<(String, String)>, syn::Error> {
+    use syn::{Ident, Token};
+    use syn::parse::{Parse, ParseStream};
+    
+    struct ParamSpecs {
+        specs: Vec<(String, String)>,
+    }
+    
+    impl Parse for ParamSpecs {
+        fn parse(input: ParseStream) -> syn::Result<Self> {
+            let mut specs = Vec::new();
+            
+            // Parse first param spec
+            if !input.is_empty() {
+                let name: Ident = input.parse()?;
+                input.parse::<Token![:]>()?;
+                let type_ident: Ident = input.parse()?;
+                
+                specs.push((name.to_string(), type_ident.to_string()));
+                
+                // Parse additional comma-separated specs
+                while input.parse::<Token![,]>().is_ok() {
+                    let name: Ident = input.parse()?;
+                    input.parse::<Token![:]>()?;
+                    let type_ident: Ident = input.parse()?;
+                    
+                    specs.push((name.to_string(), type_ident.to_string()));
+                }
+            }
+            
+            Ok(ParamSpecs { specs })
+        }
+    }
+    
+    let parsed: ParamSpecs = syn::parse2(tokens)?;
+    Ok(parsed.specs)
 }
\ No newline at end of file
diff --git a/crates/elif-http-derive/tests/parameter_metadata_test.rs b/crates/elif-http-derive/tests/parameter_metadata_test.rs
new file mode 100644
index 0000000..5598770
--- /dev/null
+++ b/crates/elif-http-derive/tests/parameter_metadata_test.rs
@@ -0,0 +1,111 @@
+use elif_http::{ElifRequest, ElifResponse, HttpResult};
+use elif_http::controller::{ElifController, ControllerRoute, RouteParam};
+use elif_http::routing::{HttpMethod, params::ParamType};
+use elif_http_derive::{controller, get, post};
+
+// Test controller with various parameter scenarios
+pub struct TestController;
+
+#[controller("/api/test")]
+impl TestController {
+    // Test 1: Basic parameter extraction without type annotation
+    #[get("/users/{id}")]
+    async fn get_user(&self, _req: ElifRequest) -> HttpResult<ElifResponse> {
+        Ok(ElifResponse::ok().text("User"))
+    }
+    
+    // Test 2: Parameter with default type (String)
+    #[get("/posts/{post_id}")]
+    async fn get_post(&self, _req: ElifRequest) -> HttpResult<ElifResponse> {
+        Ok(ElifResponse::ok().text("Post"))
+    }
+    
+    // Test 3: Multiple parameters without type annotations
+    #[get("/users/{user_id}/posts/{post_id}")]
+    async fn get_user_post(&self, _req: ElifRequest) -> HttpResult<ElifResponse> {
+        Ok(ElifResponse::ok().text("User Post"))
+    }
+    
+    // Test 4: No parameters
+    #[get("/health")]
+    async fn health(&self, _req: ElifRequest) -> HttpResult<ElifResponse> {
+        Ok(ElifResponse::ok().text("OK"))
+    }
+    
+    // Test 5: Another parameter test
+    #[post("/search/{query}")]
+    async fn search(&self, _req: ElifRequest) -> HttpResult<ElifResponse> {
+        Ok(ElifResponse::ok().text("Search"))
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    
+    #[test]
+    fn test_parameter_extraction() {
+        let controller = TestController;
+        let routes = controller.routes();
+        
+        // Test 1: Basic parameter extraction (default to String)
+        let get_user_route = routes.iter().find(|r| r.handler_name == "get_user").unwrap();
+        assert_eq!(get_user_route.params.len(), 1);
+        assert_eq!(get_user_route.params[0].name, "id");
+        assert_eq!(get_user_route.params[0].param_type, ParamType::String);
+        
+        // Test 2: Parameter with default type (String)
+        let get_post_route = routes.iter().find(|r| r.handler_name == "get_post").unwrap();
+        assert_eq!(get_post_route.params.len(), 1);
+        assert_eq!(get_post_route.params[0].name, "post_id");
+        assert_eq!(get_post_route.params[0].param_type, ParamType::String);
+        
+        // Test 3: Multiple parameters (both default to String)
+        let get_user_post_route = routes.iter().find(|r| r.handler_name == "get_user_post").unwrap();
+        assert_eq!(get_user_post_route.params.len(), 2);
+        
+        let user_id_param = get_user_post_route.params.iter().find(|p| p.name == "user_id").unwrap();
+        assert_eq!(user_id_param.param_type, ParamType::String);
+        
+        let post_id_param = get_user_post_route.params.iter().find(|p| p.name == "post_id").unwrap();
+        assert_eq!(post_id_param.param_type, ParamType::String);
+        
+        // Test 4: No parameters
+        let health_route = routes.iter().find(|r| r.handler_name == "health").unwrap();
+        assert_eq!(health_route.params.len(), 0);
+        
+        // Test 5: Another parameter with default type
+        let search_route = routes.iter().find(|r| r.handler_name == "search").unwrap();
+        assert_eq!(search_route.params.len(), 1);
+        assert_eq!(search_route.params[0].name, "query");
+        assert_eq!(search_route.params[0].param_type, ParamType::String);
+    }
+    
+    #[test]
+    fn test_route_metadata_completeness() {
+        let controller = TestController;
+        let routes = controller.routes();
+        
+        // Verify we have all expected routes
+        assert_eq!(routes.len(), 5);
+        
+        // Verify each route has the expected structure
+        for route in &routes {
+            assert!(!route.handler_name.is_empty());
+            assert!(!route.path.is_empty());
+            assert!(matches!(route.method, HttpMethod::GET | HttpMethod::POST));
+            // params field should be properly populated (tested above)
+        }
+    }
+    
+    #[test]
+    fn test_controller_introspection() {
+        let controller = TestController;
+        
+        assert_eq!(controller.name(), "TestController");
+        assert_eq!(controller.base_path(), "/api/test");
+        
+        let routes = controller.routes();
+        assert!(!routes.is_empty());
+    }
+}
\ No newline at end of file
diff --git a/crates/elif-http-derive/tests/parameter_types_test.rs b/crates/elif-http-derive/tests/parameter_types_test.rs
new file mode 100644
index 0000000..80c6649
--- /dev/null
+++ b/crates/elif-http-derive/tests/parameter_types_test.rs
@@ -0,0 +1,44 @@
+use elif_http::{ElifRequest, ElifResponse, HttpResult};
+use elif_http::controller::{ElifController, ControllerRoute, RouteParam};
+use elif_http::routing::{HttpMethod, params::ParamType};
+use elif_http_derive::{controller, get};
+
+// Test controller just for metadata extraction
+pub struct TypedController;
+
+#[controller("/api/typed")]
+impl TypedController {
+    // Test basic route with parameter
+    #[get("/test/{id}")]
+    async fn test_route(&self, _req: ElifRequest) -> HttpResult<ElifResponse> {
+        Ok(ElifResponse::ok().text("Test"))
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    
+    #[test]
+    fn test_basic_parameter_extraction() {
+        let controller = TypedController;
+        let routes = controller.routes();
+        
+        // Test basic parameter extraction
+        let test_route = routes.iter().find(|r| r.handler_name == "test_route").unwrap();
+        assert_eq!(test_route.params.len(), 1);
+        assert_eq!(test_route.params[0].name, "id");
+        assert_eq!(test_route.params[0].param_type, ParamType::String); // Default type
+    }
+    
+    #[test]
+    fn test_controller_metadata() {
+        let controller = TypedController;
+        
+        assert_eq!(controller.name(), "TypedController");
+        assert_eq!(controller.base_path(), "/api/typed");
+        
+        let routes = controller.routes();
+        assert_eq!(routes.len(), 1);
+    }
+}
\ No newline at end of file
