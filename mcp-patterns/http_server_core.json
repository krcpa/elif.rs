{
  "name": "http_server_core",
  "title": "HTTP Server Core",
  "category": "http",
  "version": "0.8.0", 
  "stability": "production",
  "description": "One-line server setup with Laravel-style response builders and pure framework types that abstract away Axum complexity",
  "tags": ["server", "http", "responses", "requests", "laravel-style", "abstractions"],
  
  "basic_example": {
    "title": "Simple Server Setup",
    "code": "use elif_http::{Server, HttpConfig, ElifRouter, ElifRequest, ElifResponse, HttpResult};\nuse elif_core::IocContainer;\n\nasync fn hello_world(_req: ElifRequest) -> HttpResult<ElifResponse> {\n    Ok(ElifResponse::ok().text(\"Hello, World!\"))\n}\n\nasync fn get_users(_req: ElifRequest) -> HttpResult<ElifResponse> {\n    let users = vec![\"Alice\", \"Bob\", \"Charlie\"];\n    Ok(ElifResponse::ok().json(&users)?)\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // One-line server setup\n    let container = IocContainer::new();\n    let config = HttpConfig::default();\n    let mut server = Server::new(container, config)?;\n    \n    // Framework-native routing\n    let router = ElifRouter::new()\n        .get(\"/\", hello_world)\n        .get(\"/users\", get_users);\n    \n    server.use_router(router);\n    \n    // Start server - simple as Laravel\n    server.listen(\"127.0.0.1:3000\").await?;\n    Ok(())\n}",
    "explanation": "Basic server setup with one-line server creation and Laravel-style routing. Framework abstracts away Axum complexity.",
    "file_source": "/crates/elif-http/src/server/server.rs:22-35"
  },
  
  "advanced_example": {
    "title": "Advanced Response Building and Framework Types",
    "code": "use elif_http::{\n    ElifRequest, ElifResponse, ElifStatusCode, ElifJson, HttpResult,\n    ElifQuery, ElifPath, ElifState, JsonResponse, ApiResponse\n};\nuse serde::{Serialize, Deserialize};\n\n#[derive(Deserialize)]\nstruct UserQuery {\n    page: Option<u32>,\n    search: Option<String>,\n}\n\n#[derive(Deserialize)]\nstruct UserPath {\n    id: u32,\n}\n\n#[derive(Serialize)]\nstruct User {\n    id: u32,\n    name: String,\n    email: String,\n}\n\n// âœ… Pure framework API - no Axum leakage\nasync fn get_user(request: ElifRequest) -> HttpResult<ElifResponse> {\n    // Framework-native parameter extraction\n    let path = ElifPath::<UserPath>::from_request(&request)?;\n    let query = ElifQuery::<UserQuery>::from_request(&request)?;\n    \n    let user_id = path.0.id;\n    let page = query.0.page.unwrap_or(1);\n    \n    // Business logic\n    let user = User {\n        id: user_id,\n        name: format!(\"User {}\", user_id),\n        email: format!(\"user{}@example.com\", user_id),\n    };\n    \n    // Laravel-style response building\n    Ok(ElifResponse::ok()\n        .json(&user)?\n        .header(\"X-User-Id\", &user_id.to_string())?\n        .header(\"X-Page\", &page.to_string())?)\n}\n\n// Advanced error handling with structured responses\nasync fn create_user(request: ElifRequest) -> HttpResult<ElifResponse> {\n    // Extract JSON body\n    let user_data: serde_json::Value = request.json().await?;\n    \n    // Validate required fields\n    if !user_data[\"name\"].is_string() {\n        return Ok(ElifResponse::with_status(ElifStatusCode::BAD_REQUEST)\n            .json(&serde_json::json!({\n                \"error\": {\n                    \"code\": \"validation_failed\",\n                    \"message\": \"Name is required\",\n                    \"field\": \"name\"\n                }\n            }))?);\n    }\n    \n    let new_user = User {\n        id: 123,\n        name: user_data[\"name\"].as_str().unwrap().to_string(),\n        email: user_data[\"email\"].as_str().unwrap_or(\"unknown\").to_string(),\n    };\n    \n    // Return Created response with location header\n    Ok(ElifResponse::with_status(ElifStatusCode::CREATED)\n        .json(&new_user)?\n        .header(\"Location\", &format!(\"/users/{}\", new_user.id))?)\n}",
    "explanation": "Advanced usage showing framework-native types, parameter extraction, and Laravel-style response building with proper error handling."
  },
  
  "when_to_use": [
    "Need simple, one-line server setup like Laravel",
    "Want framework abstractions over raw HTTP libraries",
    "Building REST APIs with consistent response patterns",
    "Need type-safe request/response handling",
    "Want Laravel/Express-style fluent response building",
    "Require clean separation from underlying HTTP implementation"
  ],
  
  "benefits": [
    "One-line server setup with Server::new().listen()",
    "Laravel-style fluent response building",
    "Framework-native types hide Axum complexity",
    "Type-safe request parameter extraction",
    "Consistent error handling patterns",
    "Built-in JSON serialization and validation",
    "Graceful shutdown and health check endpoints",
    "Integration with dependency injection container"
  ],
  
  "source_files": [
    {
      "path": "crates/elif-http/src/server/server.rs",
      "description": "Main HTTP server implementation"
    },
    {
      "path": "crates/elif-http/src/response/response.rs",
      "description": "ElifResponse builder implementation"
    },
    {
      "path": "examples/pure_framework_demo.rs",
      "description": "Framework-native types usage examples"
    },
    {
      "path": "examples/user_controller_example.rs",
      "description": "Complete server with controller patterns"
    }
  ],
  
  "related_patterns": [
    "declarative_controllers",
    "middleware_v2_system", 
    "dependency_injection",
    "error_handling"
  ],
  
  "common_mistakes": [
    {
      "mistake": "Using raw Axum types instead of framework types",
      "solution": "Use ElifRequest/ElifResponse instead of axum::Request/Response"
    },
    {
      "mistake": "Not handling JSON serialization errors",
      "solution": "Use ? operator with .json() methods for proper error propagation"
    },
    {
      "mistake": "Forgetting to configure CORS for frontend applications", 
      "solution": "Add CORS middleware or use built-in CORS configuration"
    },
    {
      "mistake": "Not using dependency injection container properly",
      "solution": "Build container before creating server and inject services"
    }
  ],
  
  "prerequisites": {
    "dependencies": [
      "elif-http = \"0.8.0\"",
      "elif-core = \"0.8.0\"", 
      "tokio = { version = \"1.0\", features = [\"rt-multi-thread\", \"macros\"] }",
      "serde = { version = \"1.0\", features = [\"derive\"] }"
    ],
    "imports": [
      "use elif_http::{Server, HttpConfig, ElifRouter, ElifRequest, ElifResponse, HttpResult};",
      "use elif_core::IocContainer;",
      "use serde::{Serialize, Deserialize};"
    ]
  },
  
  "server_configuration": {
    "title": "Server Configuration Options",
    "code": "use elif_http::{Server, HttpConfig};\nuse elif_core::IocContainer;\nuse std::time::Duration;\n\n// Basic configuration\nlet config = HttpConfig::default()\n    .port(8080)\n    .host(\"0.0.0.0\")\n    .request_timeout(Duration::from_secs(30))\n    .max_request_size(1024 * 1024); // 1MB\n\n// Development configuration with debugging\nlet dev_config = HttpConfig::development()\n    .enable_cors(true)\n    .log_requests(true)\n    .pretty_json(true);\n    \n// Production configuration\nlet prod_config = HttpConfig::production()\n    .enable_compression(true)\n    .security_headers(true)\n    .request_timeout(Duration::from_secs(60));\n\nlet container = IocContainer::new();\nlet server = Server::new(container, prod_config)?;"
  },
  
  "response_patterns": {
    "title": "Laravel-Style Response Patterns",
    "examples": [
      {
        "name": "Success Responses",
        "code": "// Simple text response\nElifResponse::ok().text(\"Hello World\")\n\n// JSON response\nElifResponse::ok().json(&data)?\n\n// Created response with location\nElifResponse::created()\n    .json(&new_resource)?\n    .header(\"Location\", \"/resources/123\")?\n\n// No content response\nElifResponse::no_content()"
      },
      {
        "name": "Error Responses", 
        "code": "// Bad request with validation errors\nElifResponse::bad_request()\n    .json(&serde_json::json!({\n        \"error\": {\n            \"code\": \"validation_failed\",\n            \"message\": \"Required fields missing\",\n            \"fields\": [\"name\", \"email\"]\n        }\n    }))?\n\n// Not found\nElifResponse::not_found()\n    .json(&serde_json::json!({\n        \"error\": {\n            \"code\": \"resource_not_found\",\n            \"message\": \"User not found\"\n        }\n    }))?\n\n// Unauthorized\nElifResponse::unauthorized()\n    .json(&serde_json::json!({\n        \"error\": {\n            \"code\": \"unauthorized\",\n            \"message\": \"Invalid credentials\"\n        }\n    }))?"
      }
    ]
  },
  
  "request_handling": {
    "title": "Request Parameter Extraction",
    "code": "use elif_http::{ElifQuery, ElifPath, ElifState};\n\n// Path parameters\nlet path = ElifPath::<UserPath>::from_request(&request)?;\nlet user_id = path.0.id;\n\n// Query parameters  \nlet query = ElifQuery::<SearchQuery>::from_request(&request)?;\nlet search_term = query.0.q;\n\n// JSON body\nlet body: CreateUserRequest = request.json().await?;\n\n// Form data\nlet form_data: HashMap<String, String> = request.form().await?;\n\n// Raw body bytes\nlet raw_body = request.body_bytes()?;\n\n// Headers\nlet auth_header = request.header(\"Authorization\");\nlet user_agent = request.header(\"User-Agent\");\n\n// Method and path\nlet method = request.method();\nlet path = request.path();"
  },
  
  "middleware_integration": {
    "title": "Integrating with Middleware", 
    "code": "use elif_http::middleware::v2::{LoggingMiddleware, CorsMiddleware};\n\nlet mut server = Server::new(container, config)?;\n\n// Add individual middleware\nserver.use_middleware(LoggingMiddleware)\n      .use_middleware(CorsMiddleware::new())\n      .use_middleware(AuthMiddleware::new(\"secret\"));\n      \n// Or use middleware pipeline\nlet middleware = MiddlewarePipelineV2::new()\n    .add(LoggingMiddleware)\n    .add(CorsMiddleware::new())\n    .add(RateLimitMiddleware::new().limit(100));\n    \nserver.use_middleware_pipeline(middleware);"
  },
  
  "health_monitoring": {
    "title": "Built-in Health Checks and Monitoring",
    "code": "// Enable built-in health check endpoint\nlet config = HttpConfig::default()\n    .enable_health_check(\"/health\")\n    .enable_metrics(\"/metrics\")\n    .enable_ready_check(\"/ready\");\n\n// Custom health checks\nstruct DatabaseHealthCheck;\n\nimpl HealthCheck for DatabaseHealthCheck {\n    async fn check(&self) -> HealthResult {\n        // Check database connectivity\n        match db_pool.get().await {\n            Ok(_) => HealthResult::healthy(\"Database connected\"),\n            Err(e) => HealthResult::unhealthy(&format!(\"Database error: {}\", e))\n        }\n    }\n}\n\nserver.add_health_check(\"database\", DatabaseHealthCheck);"
  },
  
  "testing": {
    "title": "Testing HTTP Server",
    "code": "#[cfg(test)]\nmod tests {\n    use super::*;\n    use elif_http::testing::TestClient;\n    \n    #[tokio::test]\n    async fn test_server_endpoints() {\n        let container = IocContainer::new();\n        let server = Server::new(container, HttpConfig::test())?;\n        \n        let client = TestClient::new(server);\n        \n        // Test GET request\n        let response = client.get(\"/users\").await;\n        assert_eq!(response.status(), 200);\n        \n        // Test POST with JSON\n        let user_data = serde_json::json!({\n            \"name\": \"John Doe\",\n            \"email\": \"john@example.com\"\n        });\n        \n        let response = client\n            .post(\"/users\")\n            .json(&user_data)\n            .await;\n            \n        assert_eq!(response.status(), 201);\n        let created_user: User = response.json().await?;\n        assert_eq!(created_user.name, \"John Doe\");\n    }\n}"
  },
  
  "performance": {
    "notes": [
      "Built on Axum/Hyper for production-ready performance", 
      "Connection pooling and keep-alive support",
      "Async/await throughout for optimal concurrency",
      "Zero-copy serialization where possible",
      "Built-in compression and caching middleware"
    ],
    "benchmarks": [
      "Simple \"Hello World\": ~200k requests/sec",
      "JSON serialization: ~150k requests/sec", 
      "With middleware pipeline: ~100k requests/sec",
      "Database integration: depends on DB performance"
    ]
  },
  
  "deployment": {
    "title": "Production Deployment",
    "code": "// Production server configuration\nuse std::env;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Load configuration from environment\n    let port = env::var(\"PORT\")\n        .unwrap_or_else(|_| \"3000\".to_string())\n        .parse::<u16>()?;\n        \n    let host = env::var(\"HOST\")\n        .unwrap_or_else(|_| \"0.0.0.0\".to_string());\n    \n    let config = HttpConfig::production()\n        .port(port)\n        .host(&host)\n        .enable_compression(true)\n        .security_headers(true)\n        .request_timeout(Duration::from_secs(60));\n    \n    let container = IocContainer::new();\n    let mut server = Server::new(container, config)?;\n    \n    // Add production middleware\n    server.use_middleware(SecurityHeadersMiddleware::new())\n          .use_middleware(CompressionMiddleware::new())\n          .use_middleware(RequestLoggingMiddleware::new());\n    \n    // Graceful shutdown\n    server.with_graceful_shutdown(shutdown_signal());\n    \n    println!(\"ðŸš€ Server starting on {}:{}\", host, port);\n    server.listen(&format!(\"{}:{}\", host, port)).await?;\n    \n    Ok(())\n}\n\nasync fn shutdown_signal() {\n    tokio::signal::ctrl_c()\n        .await\n        .expect(\"Failed to install Ctrl+C handler\");\n    println!(\"Shutting down gracefully...\");\n}"
  },
  
  "limitations": [
    "Currently abstracts Axum - may limit some advanced Axum features",
    "Response body can only be read once in middleware",
    "Some performance optimizations may require dropping to Axum level",
    "WebSocket support still in development"
  ]
}