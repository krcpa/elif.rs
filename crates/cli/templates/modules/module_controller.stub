use elif::prelude::*;
use super::{{ feature_name }}_service::{{ feature_name_pascal }}Service;
use super::dto::{Create{{ feature_name_pascal }}Dto, Update{{ feature_name_pascal }}Dto};

#[derive(Clone, Default)]
pub struct {{ feature_name_pascal }}Controller {
    service: {{ feature_name_pascal }}Service,
}

#[controller("/api/{{ feature_name_plural }}")]
impl {{ feature_name_pascal }}Controller {
    pub fn new(service: {{ feature_name_pascal }}Service) -> Self {
        Self { service }
    }

    #[get("")]
    pub async fn index(&self, _req: ElifRequest) -> HttpResult<ElifResponse> {
        let items = self.service.find_all().await;
        Ok(ElifResponse::ok().json(&items)?)
    }
    
    #[get("/{id}")]
    #[param(id: u32)]
    pub async fn show(&self, id: u32, _req: ElifRequest) -> HttpResult<ElifResponse> {
        let item = self.service.find_by_id(id).await?;
        Ok(ElifResponse::ok().json(&item)?)
    }
    
    #[post("")]
    #[body(data: Create{{ feature_name_pascal }}Dto)]
    pub async fn create(&self, data: Create{{ feature_name_pascal }}Dto) -> HttpResult<ElifResponse> {
        let item = self.service.create(data).await?;
        Ok(ElifResponse::created().json(&item)?)
    }
    
    #[put("/{id}")]
    #[param(id: u32)]
    #[body(data: Update{{ feature_name_pascal }}Dto)]
    pub async fn update(&self, id: u32, data: Update{{ feature_name_pascal }}Dto) -> HttpResult<ElifResponse> {
        let item = self.service.update(id, data).await?;
        Ok(ElifResponse::ok().json(&item)?)
    }
    
    #[delete("/{id}")]
    #[param(id: u32)]
    pub async fn delete(&self, id: u32, _req: ElifRequest) -> HttpResult<ElifResponse> {
        self.service.delete(id).await?;
        Ok(ElifResponse::no_content())
    }
}